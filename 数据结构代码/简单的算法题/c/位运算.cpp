#include <stdio.h>
/**
*计算出一个数的二进制出现多少个1 
*基本算法：将数字进行按位与运算& 1 ，因为1的二进制前面都是0 
*输入的数字进入计算机都是2进制 
*所以运算后，如果得出来的是1，那么1就出现一次，然后向右移一位，继续判断，直到数大于0 
*/
int countOnes(int num) {
	int count = 0;
	while (num > 0) {
		if( ( num & 1) == 1) {
			count++;
		 }
			num = (num >> 1);
	}
		return count;
}

/**
*算法优化：将二进制括成两个两个，不断相加，直到二进制的左边是一个数，二进制的右边是一个数 
* 因为需要不断相邻的两个数相加，那么二进制需要过滤 
*在第一个时，用01过滤右边的数字出来，然后将二进制右移一位，再用01把左边的数过滤出来，。 
*把过滤好的二进制相加，所得的数就是已经左右两边加好的二进制 
*再将其二进制过滤相加，使用0011过滤，同理右移2位。........ 
*在32位上，最后是需要两对的16位相加，所得出的答案就是有几个1 
*
*/ 
int countOnes2(int a) {
	int m_1  = 0x55555555;
	int m_2  = 0x33333333;
	int m_4  = 0x0f0f0f0f;
	int m_8  = 0x00ff00ff;
	int m_16 = 0x0000ffff;
	
	int b = (a & m_1) + ( (a >> 1) & m_1 );
	int c = (b & m_2) + ( (b >> 3) & m_2 );
	int d = (c & m_4) + ( (c >> 4) & m_4 );
	int e = (d & m_8) + ( (d >> 8) & m_8 );
	int f = (e & m_16) + ( (e >> 1) & m_16 );
	return f;
}

int main() {
	int c1 = countOnes(13);
	int c2 = countOnes2(13);
	printf("%d\n", c1);
	printf("%d\n", c2);

	return 0;
}
